export PEGA_REST_SERVER_URL="$pega_rest_server_url"
export PEGA_REST_USERNAME="$pega_rest_username"
export PEGA_REST_PASSWORD="$pega_rest_password"
export APPLICATION_NAME="$application_Name"
export APPLICATION_VERSION="$application_Version"
export PROJECT_NAME="$project_name"
export PROJECT_VERSION="$project_version"

# Generate final properties file
envsubst < prpcServiceUtils_export.template.properties > prpcServiceUtils_export.properties

# Debug print
cat prpcServiceUtils_export.properties



prpcServiceUtils_export.template.properties
# REST connection
pega.rest.server.url=${PEGA_REST_SERVER_URL}
pega.rest.username=${PEGA_REST_USERNAME}
pega.rest.password=${PEGA_REST_PASSWORD}

# Export by application or product
export.applicationName=${APPLICATION_NAME}
export.applicationVersion=${APPLICATION_VERSION}

export.productName=${PROJECT_NAME}
export.productVersion=${PROJECT_VERSION}

# Archive path - dynamically use projectName + projectVersion
export.archiveName=/data/prpcsrvutils/export/${APPLICATION_NAME}_${PROJECT_NAME}_${PROJECT_VERSION}.zip

export.exportToRepository=false
export.async=false

-------------------------

Add a Bash step after export (like file1 did with mv):


set -Eeuo pipefail

# Where your export writes
EXPORT_ROOT="/data/prpcsrvrutils/export"
# Artifact staging dir from Azure DevOps
STAGING_DIR="$(Build.ArtifactStagingDirectory)"

# Find the latest zip (newest by timestamp)
latest_zip=$(find "$EXPORT_ROOT" -type f -name "*.zip" -printf "%T@ %p\n" | sort -nr | head -n1 | awk '{print $2}')

if [ -z "$latest_zip" ]; then
  echo "‚ùå No zip file found in $EXPORT_ROOT"
  exit 1
fi

echo "‚úÖ Found latest zip: $latest_zip"

# Rename with BuildId (same idea as file1 logic)
artifact_name="PegaExport_${BUILD_BUILDID}.zip"

# Stage it
mkdir -p "$STAGING_DIR"
cp "$latest_zip" "$STAGING_DIR/$artifact_name"

echo "üì¶ Staged artifact:"
ls -l "$STAGING_DIR"
